apiVersion: v1
kind: ServiceAccount
metadata:
  name: chains-admin
  namespace: openshift-pipelines
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: chains-admin
  namespace: openshift-pipelines
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  - configmaps
  - pods
  verbs:
  - '*'
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-reader
  namespace: openshift-ingress-operator
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: chains-admin
  namespace: openshift-pipelines
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: chains-admin
subjects:
- kind: ServiceAccount
  name: chains-admin
  namespace: openshift-pipelines
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: chains-secret-reader
  namespace: openshift-ingress-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: secret-reader
subjects:
- kind: ServiceAccount
  name: chains-admin
  namespace: openshift-pipelines
---
apiVersion: batch/v1
kind: Job
metadata:
  name: chains-certs-configuration
  namespace: openshift-pipelines
  annotations:
    argocd.argoproj.io/hook: PostSync
spec:
  template:
    spec:
      containers:
        - image: registry.redhat.io/openshift4/ose-cli:v4.9
          command:
            - /bin/bash
            - -c
            - |
              echo "Waiting for secret and configmaps to be present"
              until oc get cm config-trusted-cabundle -n openshift-pipelines &&\
                oc get cm kube-root-ca.crt -n openshift-pipelines
              do
                sleep 5;
              done

              # Replace the config-trusted-cabundle with cluster certs, trusted-ca's and ingress cert.
              echo "Build the certificate and replace cm/config-trusted-cabundle"
              TRUSTED_CA=$(mktemp)
              KUBE_CA=$(mktemp)
              INGRESS_CA=$(mktemp)
              BUNDLE_CA=$(mktemp)
              oc get cm config-trusted-cabundle -n default -o jsonpath="{.data.ca-bundle\.crt}" > $TRUSTED_CA
              oc get cm kube-root-ca.crt -n openshift-pipelines -o jsonpath="{.data.ca\.crt}" > $KUBE_CA
              oc get secret router-ca -n openshift-ingress-operator -o jsonpath="{.data.tls\.crt}" | base64 -d > $INGRESS_CA
              SERVICE_CA=/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt
              cat $TRUSTED_CA $KUBE_CA $INGRESS_CA $SERVICE_CA > $BUNDLE_CA
              oc delete cm config-trusted-cabundle -n openshift-pipelines
              CONFIG_TRUSTED_YAML=$(mktemp)
              cat <<EOF > $CONFIG_TRUSTED_YAML
              apiVersion: v1
              data:
                ca-bundle.crt: |
                  $(sed -e '1 ! s/^/    /g' $BUNDLE_CA)
              kind: ConfigMap
              metadata:
                name: config-trusted-cabundle
                namespace: openshift-pipelines
              EOF
              oc create -f $CONFIG_TRUSTED_YAML
              # restart pod to re-mount the bundle
              oc delete po -l app=tekton-chains-controller -n openshift-pipelines
          imagePullPolicy: Always
          name: patch-chains-certs
      dnsPolicy: ClusterFirst
      restartPolicy: OnFailure
      terminationGracePeriodSeconds: 30
      serviceAccount: chains-admin
      serviceAccountName: chains-admin
---
apiVersion: batch/v1
kind: Job
metadata:
  name: tekton-chains-signing-secret
  namespace: openshift-pipelines
  annotations:
    argocd.argoproj.io/hook: PostSync
spec:
  template:
    spec:
      containers:
      - name: chains-secret-generation
        image: quay.io/redhat-appstudio/appstudio-utils:eb94f28fe2d7c182f15e659d0fdb66f87b0b3b6b
        imagePullPolicy: Always
        command:
        - /bin/bash
        - -c
        - |
          cd /tmp
          # Once the key-pair has been set it's marked as immutable so it can't be updated.
          # Try to handle that nicely. The object is expected to always exist so check the data.
          SIG_KEY_DATA=$(kubectl get secret signing-secrets -n openshift-pipelines -o jsonpath='{.data}')
          [[ -n $SIG_KEY_DATA ]] && echo "Signing secret exists." && exit

          # To make this run conveniently without user input let's create a random password
          RANDOM_PASS=$( head -c 12 /dev/urandom | base64 )

          # Generates the key pair secret directly in the cluster.
          env COSIGN_PASSWORD=$RANDOM_PASS cosign generate-key-pair k8s://openshift-pipelines/signing-secrets
      dnsPolicy: ClusterFirst
      restartPolicy: OnFailure
      terminationGracePeriodSeconds: 30
      serviceAccount: chains-admin
      serviceAccountName: chains-admin
